<?php

declare(strict_types=1);

/**
 * ParcelDocumentsApi
 * PHP version 7.2
 *
 * @category Class
 * @package  Toppy\Sendcloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
/**
 * Sendcloud Public REST API
 *
 * Complete Sendcloud API v2 specification - merged from official Stoplight documentation bundles
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: contact@sendcloud.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.18.0
 */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
namespace Toppy\Sendcloud\Api;

use GuzzleHttp\Psr7\MultipartStream;
use Http\Client\Common\Plugin\ErrorPlugin;
use Http\Client\Common\Plugin\RedirectPlugin;
use Http\Client\Common\PluginClient;
use Http\Client\Common\PluginClientFactory;
use Http\Client\Exception\HttpException;
use Http\Client\HttpAsyncClient;
use Http\Discovery\HttpAsyncClientDiscovery;
use Http\Discovery\Psr17FactoryDiscovery;
use Http\Discovery\Psr18ClientDiscovery;
use Http\Message\RequestFactory;
use Http\Promise\Promise;
use Toppy\Sendcloud\ApiException;
use Toppy\Sendcloud\Configuration;
use Toppy\Sendcloud\DebugPlugin;
use Toppy\Sendcloud\HeaderSelector;
use Toppy\Sendcloud\FormDataProcessor;
use Toppy\Sendcloud\ObjectSerializer;
use Psr\Http\Client\ClientExceptionInterface;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\UriFactoryInterface;
use Psr\Http\Message\UriInterface;
use function sprintf;

/**
 * ParcelDocumentsApi Class Doc Comment
 *
 * @category Class
 * @package  Toppy\Sendcloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ParcelDocumentsApi
{
    /**
     * @var PluginClient
     */
    protected $httpClient;

    /**
     * @var PluginClient
     */
    protected $httpAsyncClient;

    /**
     * @var UriFactoryInterface
     */
    protected $uriFactory;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var RequestFactoryInterface
     */
    protected $requestFactory;

    /**
     * @var StreamFactoryInterface
     */
    protected $streamFactory;

    /**
     * @param int $hostIndex
     */
    public function __construct(
        ?ClientInterface $httpClient = null,
        ?Configuration $configuration = null,
        ?HttpAsyncClient $httpAsyncClient = null,
        ?UriFactoryInterface $uriFactory = null,
        ?RequestFactoryInterface $requestFactory = null,
        ?StreamFactoryInterface $streamFactory = null,
        protected ?HeaderSelector $headerSelector = new HeaderSelector(),
        ?array $plugins = null,
        /**
         * @var int Host index
         */
        protected $hostIndex = 0
    ) {
        $this->config = $configuration ?? (new Configuration())->setHost('https://account.sendcloud.com');
        $this->requestFactory = $requestFactory ?? Psr17FactoryDiscovery::findRequestFactory();
        $this->streamFactory = $streamFactory ?? Psr17FactoryDiscovery::findStreamFactory();

        $plugins = $plugins ?? [
            new RedirectPlugin(['strict' => true]),
            new ErrorPlugin(),
        ];

        if ($this->config->getDebug()) {
            $plugins[] = new DebugPlugin(fopen($this->config->getDebugFile(), 'ab'));
        }

        $this->httpClient = (new PluginClientFactory())->createClient(
            $httpClient ?? Psr18ClientDiscovery::find(),
            $plugins
        );

        $this->httpAsyncClient = (new PluginClientFactory())->createClient(
            $httpAsyncClient ?? HttpAsyncClientDiscovery::find(),
            $plugins
        );

        $this->uriFactory = $uriFactory ?? Psr17FactoryDiscovery::findUriFactory();
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation scPublicV2ScpGetRetrieveParcelDocuments
     *
     * Retrieve Parcel Documents
     *
     * @param  int $id Identifier of the parcel which you want to retrieve a document from (required)
     * @param  string $type Document type you want to retrieve for this parcel (required)
     * @param  int $dpi DPI refers to the printing resolution of your shipping labels. It&#39;s important that labels are printed at a high enough resolution to ensure the clarity of address details and the barcode for scanning purposes. Use following amounts for appropriate result: &lt;table&gt;   &lt;thead&gt;     &lt;tr&gt;       &lt;th&gt;File format&lt;/th&gt;       &lt;th&gt;Default DPI&lt;/th&gt;       &lt;th&gt;Valid DPI&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;td&gt;pdf&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;td&gt;png&lt;/td&gt;       &lt;td&gt;300&lt;/td&gt;       &lt;td&gt;150, 300&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt; ZPL labels are not affected by the DPI setting, as the resolution is determined by the carrier itself. Most carriers use a resolution of 203 DPI. Zebra printers need to be configured to print at the specific DPI of the label if they have higher resolution capabilities. (optional, default to 72)
     * @param  string $accept The returned format of the document (optional, default to 'application/pdf')
     * @param  bool $raw There have been identified cases where custom documents, internally rendered, will only include some of the necessary information, mainly due to some restrictions. Using the raw query param, one can request to receive the document in the originally received format by the carrier. This temporary solution to the problem allows the normal operations of the affected customers. As such, you can expect this property to be sunsetted shortly once the necessary changes have been implemented. (optional)
     *
     * @throws \Toppy\Sendcloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\Toppy\Sendcloud\Model\ScPublicV2ScpGetRetrieveParcelDocuments404Response
     */
    public function scPublicV2ScpGetRetrieveParcelDocuments($id, $type, $dpi = 72, $accept = 'application/pdf', $raw = null)
    {
        [$response] = $this->scPublicV2ScpGetRetrieveParcelDocumentsWithHttpInfo($id, $type, $dpi, $accept, $raw);
        return $response;
    }

    /**
     * Operation scPublicV2ScpGetRetrieveParcelDocumentsWithHttpInfo
     *
     * Retrieve Parcel Documents
     *
     * @param  int $id Identifier of the parcel which you want to retrieve a document from (required)
     * @param  string $type Document type you want to retrieve for this parcel (required)
     * @param  int $dpi DPI refers to the printing resolution of your shipping labels. It&#39;s important that labels are printed at a high enough resolution to ensure the clarity of address details and the barcode for scanning purposes. Use following amounts for appropriate result: &lt;table&gt;   &lt;thead&gt;     &lt;tr&gt;       &lt;th&gt;File format&lt;/th&gt;       &lt;th&gt;Default DPI&lt;/th&gt;       &lt;th&gt;Valid DPI&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;td&gt;pdf&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;td&gt;png&lt;/td&gt;       &lt;td&gt;300&lt;/td&gt;       &lt;td&gt;150, 300&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt; ZPL labels are not affected by the DPI setting, as the resolution is determined by the carrier itself. Most carriers use a resolution of 203 DPI. Zebra printers need to be configured to print at the specific DPI of the label if they have higher resolution capabilities. (optional, default to 72)
     * @param  string $accept The returned format of the document (optional, default to 'application/pdf')
     * @param  bool $raw There have been identified cases where custom documents, internally rendered, will only include some of the necessary information, mainly due to some restrictions. Using the raw query param, one can request to receive the document in the originally received format by the carrier. This temporary solution to the problem allows the normal operations of the affected customers. As such, you can expect this property to be sunsetted shortly once the necessary changes have been implemented. (optional)
     *
     * @throws \Toppy\Sendcloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\Toppy\Sendcloud\Model\ScPublicV2ScpGetRetrieveParcelDocuments404Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function scPublicV2ScpGetRetrieveParcelDocumentsWithHttpInfo($id, $type, $dpi = 72, $accept = 'application/pdf', $raw = null)
    {
        $request = $this->scPublicV2ScpGetRetrieveParcelDocumentsRequest($id, $type, $dpi, $accept, $raw);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    sprintf('[%d] %s', $e->getCode(), $e->getMessage()),
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        \Toppy\Sendcloud\Model\ScPublicV2ScpGetRetrieveParcelDocuments404Response::class,
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $request,
                    $response
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $apiException) {
            switch ($apiException->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $apiException->getResponseBody(),
                        '\SplFileObject',
                        $apiException->getResponseHeaders()
                    );
                    $apiException->setResponseObject($data);
                    throw $apiException;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $apiException->getResponseBody(),
                        \Toppy\Sendcloud\Model\ScPublicV2ScpGetRetrieveParcelDocuments404Response::class,
                        $apiException->getResponseHeaders()
                    );
                    $apiException->setResponseObject($data);
                    throw $apiException;
            }
        

            throw $apiException;
        }
    }

    /**
     * Operation scPublicV2ScpGetRetrieveParcelDocumentsAsync
     *
     * Retrieve Parcel Documents
     *
     * @param  int $id Identifier of the parcel which you want to retrieve a document from (required)
     * @param  string $type Document type you want to retrieve for this parcel (required)
     * @param  int $dpi DPI refers to the printing resolution of your shipping labels. It&#39;s important that labels are printed at a high enough resolution to ensure the clarity of address details and the barcode for scanning purposes. Use following amounts for appropriate result: &lt;table&gt;   &lt;thead&gt;     &lt;tr&gt;       &lt;th&gt;File format&lt;/th&gt;       &lt;th&gt;Default DPI&lt;/th&gt;       &lt;th&gt;Valid DPI&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;td&gt;pdf&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;td&gt;png&lt;/td&gt;       &lt;td&gt;300&lt;/td&gt;       &lt;td&gt;150, 300&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt; ZPL labels are not affected by the DPI setting, as the resolution is determined by the carrier itself. Most carriers use a resolution of 203 DPI. Zebra printers need to be configured to print at the specific DPI of the label if they have higher resolution capabilities. (optional, default to 72)
     * @param  string $accept The returned format of the document (optional, default to 'application/pdf')
     * @param  bool $raw There have been identified cases where custom documents, internally rendered, will only include some of the necessary information, mainly due to some restrictions. Using the raw query param, one can request to receive the document in the originally received format by the carrier. This temporary solution to the problem allows the normal operations of the affected customers. As such, you can expect this property to be sunsetted shortly once the necessary changes have been implemented. (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function scPublicV2ScpGetRetrieveParcelDocumentsAsync($id, $type, $dpi = 72, $accept = 'application/pdf', $raw = null)
    {
        return $this->scPublicV2ScpGetRetrieveParcelDocumentsAsyncWithHttpInfo($id, $type, $dpi, $accept, $raw)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scPublicV2ScpGetRetrieveParcelDocumentsAsyncWithHttpInfo
     *
     * Retrieve Parcel Documents
     *
     * @param  int $id Identifier of the parcel which you want to retrieve a document from (required)
     * @param  string $type Document type you want to retrieve for this parcel (required)
     * @param  int $dpi DPI refers to the printing resolution of your shipping labels. It&#39;s important that labels are printed at a high enough resolution to ensure the clarity of address details and the barcode for scanning purposes. Use following amounts for appropriate result: &lt;table&gt;   &lt;thead&gt;     &lt;tr&gt;       &lt;th&gt;File format&lt;/th&gt;       &lt;th&gt;Default DPI&lt;/th&gt;       &lt;th&gt;Valid DPI&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;td&gt;pdf&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;td&gt;png&lt;/td&gt;       &lt;td&gt;300&lt;/td&gt;       &lt;td&gt;150, 300&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt; ZPL labels are not affected by the DPI setting, as the resolution is determined by the carrier itself. Most carriers use a resolution of 203 DPI. Zebra printers need to be configured to print at the specific DPI of the label if they have higher resolution capabilities. (optional, default to 72)
     * @param  string $accept The returned format of the document (optional, default to 'application/pdf')
     * @param  bool $raw There have been identified cases where custom documents, internally rendered, will only include some of the necessary information, mainly due to some restrictions. Using the raw query param, one can request to receive the document in the originally received format by the carrier. This temporary solution to the problem allows the normal operations of the affected customers. As such, you can expect this property to be sunsetted shortly once the necessary changes have been implemented. (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function scPublicV2ScpGetRetrieveParcelDocumentsAsyncWithHttpInfo($id, $type, $dpi = 72, $accept = 'application/pdf', $raw = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->scPublicV2ScpGetRetrieveParcelDocumentsRequest($id, $type, $dpi, $accept, $raw);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $httpException) {
                    $response = $httpException->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $httpException->getRequest()->getUri()
                        ),
                        $httpException->getRequest(),
                        $httpException->getResponse(),
                        $httpException
                    );
                }
            );
    }

    /**
     * Create request for operation 'scPublicV2ScpGetRetrieveParcelDocuments'
     *
     * @param  int $id Identifier of the parcel which you want to retrieve a document from (required)
     * @param  string $type Document type you want to retrieve for this parcel (required)
     * @param  int $dpi DPI refers to the printing resolution of your shipping labels. It&#39;s important that labels are printed at a high enough resolution to ensure the clarity of address details and the barcode for scanning purposes. Use following amounts for appropriate result: &lt;table&gt;   &lt;thead&gt;     &lt;tr&gt;       &lt;th&gt;File format&lt;/th&gt;       &lt;th&gt;Default DPI&lt;/th&gt;       &lt;th&gt;Valid DPI&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;td&gt;pdf&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;       &lt;td&gt;72&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;td&gt;png&lt;/td&gt;       &lt;td&gt;300&lt;/td&gt;       &lt;td&gt;150, 300&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt; ZPL labels are not affected by the DPI setting, as the resolution is determined by the carrier itself. Most carriers use a resolution of 203 DPI. Zebra printers need to be configured to print at the specific DPI of the label if they have higher resolution capabilities. (optional, default to 72)
     * @param  string $accept The returned format of the document (optional, default to 'application/pdf')
     * @param  bool $raw There have been identified cases where custom documents, internally rendered, will only include some of the necessary information, mainly due to some restrictions. Using the raw query param, one can request to receive the document in the originally received format by the carrier. This temporary solution to the problem allows the normal operations of the affected customers. As such, you can expect this property to be sunsetted shortly once the necessary changes have been implemented. (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function scPublicV2ScpGetRetrieveParcelDocumentsRequest($id, $type, $dpi = 72, $accept = 'application/pdf', $raw = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && $id === [])) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling scPublicV2ScpGetRetrieveParcelDocuments'
            );
        }

        if ($id < 1) {
            throw new \InvalidArgumentException('invalid value for "$id" when calling ParcelDocumentsApi.scPublicV2ScpGetRetrieveParcelDocuments, must be bigger than or equal to 1.');
        }

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && $type === [])) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling scPublicV2ScpGetRetrieveParcelDocuments'
            );
        }

        if ($dpi !== null && $dpi < 1) {
            throw new \InvalidArgumentException('invalid value for "$dpi" when calling ParcelDocumentsApi.scPublicV2ScpGetRetrieveParcelDocuments, must be bigger than or equal to 1.');
        }


        $resourcePath = '/parcels/{id}/documents/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;

        // query params
        if ($dpi !== null) {
            if(is_array($dpi)) {
                foreach($dpi as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dpi'] = $dpi;
            }
        }

        // query params
        if ($raw !== null) {
            if(is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw;
            }
        }

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // path params
        $resourcePath = str_replace(
            '{id}',
            ObjectSerializer::toPathValue($id),
            $resourcePath
        );

        // path params
        $resourcePath = str_replace(
            '{type}',
            ObjectSerializer::toPathValue($type),
            $resourcePath
        );


        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/zpl', 'image/png', 'application/json'],
            '',
            $multipart
        );

        // for model (json/xml)
        if ($formParams !== []) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }

                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('GET', $uri, $headers, $httpBody);
    }


    /**
     * @param string|UriInterface $uri
     * @param string|StreamInterface|null $body
     *
     */
    protected function createRequest(string $method, $uri, array $headers = [], $body = null): RequestInterface
    {
        if ($this->requestFactory instanceof RequestFactory) {
            return $this->requestFactory->createRequest(
                $method,
                $uri,
                $headers,
                $body
            );
        }

        if (is_string($body) && '' !== $body && null === $this->streamFactory) {
            throw new \RuntimeException('Cannot create request: A stream factory is required to create a request with a non-empty string body.');
        }

        $request = $this->requestFactory->createRequest($method, $uri);

        foreach ($headers as $key => $value) {
            $request = $request->withHeader($key, $value);
        }

        if (null !== $body && '' !== $body) {
            return $request->withBody(
                is_string($body) ? $this->streamFactory->createStream($body) : $body
            );
        }

        return $request;
    }

    /**
     * @param array<string, int>|array<string, bool> $queryParams
     */
    private function createUri(
        string $operationHost,
        string $resourcePath,
        array $queryParams
    ): UriInterface {
        $parsedUrl = parse_url($operationHost);

        $host = $parsedUrl['host'] ?? null;
        $scheme = $parsedUrl['scheme'] ?? null;
        $basePath = $parsedUrl['path'] ?? null;
        $port = $parsedUrl['port'] ?? null;
        $user = $parsedUrl['user'] ?? null;
        $password = $parsedUrl['pass'] ?? null;

        $uri = $this->uriFactory->createUri($basePath . $resourcePath)
            ->withHost($host)
            ->withScheme($scheme)
            ->withPort($port)
            ->withQuery(ObjectSerializer::buildQuery($queryParams));

        if ($user) {
            return $uri->withUserInfo($user, $password);
        }

        return $uri;
    }

    /**
     * @return array<int, object|int|mixed[]|null>
     */
    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
			$request,
                        $response,
                        $exception
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }
}
